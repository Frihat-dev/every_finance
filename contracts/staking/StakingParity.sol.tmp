// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "./ParityData.sol";
import "./IParityStorage.sol";

contract StakingToken is Ownable, Pausable {
    using Math for uint256;
    using SafeERC20 for IERC20;
    uint256 public constant COEFF_SCALE_DECIMALS = 1e18;

    struct Pack {
        address rewardToken;
        Amount rewardTotal;
        uint256 startTime;
        uint256 periodFinish;
        uint256 lastUpdateTime;
        uint256 rewardDuration;
        uint256 rewardPerSecond;
        Amount rewardPerTokenStored;
        Amount minBoostingFactor;
        Amount minTotalSupply;
    }
    struct Balance {
        Amount amount0;
        uint256 amount1;
    }

    struct TotalSupply {
        Amount amount0;
        uint256 amount1;
    }

    uint256 public idealRatio;
    uint256 public idealAmount;
    address public treasury;
    TotalSupply private totalSupply;
    Pack[] public packs;
    mapping(uint256 => mapping(uint256 => uint256)) public rewardPerTokenPaid;
    mapping(uint256 => mapping(uint256 => uint256)) public rewards;
    mapping(uint256 => Balance) private balances;
    mapping(uint256 => Amount) private weights;
    mapping(uint256 => address) private holders;
    IParityStorage public parityStorage;
    IERC721 public parityToken;
    IERC20 public token1;

    event Staked(uint256 _tokenId, uint256 _amount1, address indexed _to);
    event Unstaked(uint256 _tokenId, uint256 _amount1, address indexed _to);
    event RewardPaid(
        address indexed _rewardToken,
        uint256 _reward,
        address indexed _to
    );
    event RewardAdded(uint256 _id, uint256 _reward);
    event RewardsDurationUpdated(uint256 _id, uint256 _rewardsDuration);

    constructor(
        address _parityToken,
        address _parityStorage,
        address _token1,
        address _treasury
    ) {
        require(_token1 != address(0), "Formation.Fi: zero address");
        require(_treasury != address(0), "Formation.Fi: zero address");
        require(_parityToken != address(0), "Formation.Fi: zero address");
        require(_parityStorage != address(0), "Formation.Fi: zero address");
        parityStorage = IParityStorage(_parityStorage);
        parityToken = IERC721(_parityToken);
        token1 = IERC20(_token1);
        treasury = _treasury;
    }

    modifier updateReward() {
        for (uint256 i = 0; i < packs.length; i++) {
            packs[i].rewardPerTokenStored = rewardPerToken(i);
            packs[i].lastUpdateTime = lastTimeReward(i);
        }
        _;
    }

    function _updateReward(uint256 tokenId_) internal {
        for (uint256 i = 0; i < packs.length; i++) {
            rewards[i][tokenId_] += earned(i, tokenId_);
            rewardPerTokenPaid[i][tokenId_] = packs[i].rewardPerTokenStored;
        }
    }

    function setTotalSupply(
        TotalSupply memory _totalSupply
    ) external onlyOwner {
        totalSupply = _totalSupply;
    }

    function setRatio(uint256 _idealRatio) external onlyOwner {
        idealRatio = _idealRatio;
    }

    function setIdealAmount(uint256 _idealAmount) external onlyOwner {
        idealAmount = _idealAmount;
    }

    function addPack(
        address _rewardToken,
        uint256 _startTime,
        uint256 _rewardDuration,
        uint256 _minBoostingFactor,
        uint256 _minTotalSupply
    ) external onlyOwner {
        packs.push(
            Pack(
                _rewardToken,
                0,
                _startTime,
                0,
                0,
                _rewardDuration,
                0,
                0,
                _minBoostingFactor,
                _minTotalSupply
            )
        );
    }

    function updateRewardDuration(
        uint256 _id,
        uint256 _rewardDuration
    ) external onlyOwner {
        require(_id < packs.length, "Formation.Fi: no pack");
        packs[_id].rewardDuration = _rewardDuration;
    }

    function getTotalSupply() external view returns (TotalSupply memory) {
        return totalSupply;
    }

    function balanceOf(
        uint256 tokenId_
    ) external view returns (Balance memory) {
        return balances[tokenId_];
    }

    function lastTimeReward(uint256 _id) public view returns (uint256) {
        require(_id < packs.length, "Formation.Fi: no pack");
        uint256 _periodFinish = packs[_id].periodFinish;
        return
            block.timestamp < _periodFinish ? block.timestamp : _periodFinish;
    }

    function rewardPerToken(uint256 _id) public view returns (Amount memory) {
        require(_id < packs.length, "Formation.Fi: no pack");
        Pack memory _pack = packs[_id];
        Amount memory _rewardPerTokenStored;
        if (totalSupply.amount0.alpha == 0) {
           _rewardPerTokenStored.alpha = _pack.rewardPerTokenStored.alpha;
        }
        else {
          _rewardPerTokenStored.alpha = _pack.rewardPerTokenStored.alpha +
            (((lastTimeReward(_id) - _pack.lastUpdateTime) *
                _pack.rewardPerSecond.alpha) * COEFF_SCALE_DECIMALS) /
            Math.max(totalSupply.amount0.alpha, _pack.minTotalSupply.alpha);
        }

        if (totalSupply.amount0.beta == 0) {
           _rewardPerTokenStored.beta = _pack.rewardPerTokenStored.beta;
        }
        else {
          _rewardPerTokenStored.beta = _pack.rewardPerTokenStored.beta +
            (((lastTimeReward(_id) - _pack.lastUpdateTime) *
                _pack.rewardPerSecond.beta) * COEFF_SCALE_DECIMALS) /
            Math.max(totalSupply.amount0.beta, _pack.minTotalSupply.beta);
        }

        if (totalSupply.amount0.gamma == 0) {
           _rewardPerTokenStored.gamma = _pack.rewardPerTokenStored.gamma;
        }
        else {
          _rewardPerTokenStored.gamma = _pack.rewardPerTokenStored.gamma +
            (((lastTimeReward(_id) - _pack.lastUpdateTime) *
                _pack.rewardPerSecond.gamma) * COEFF_SCALE_DECIMALS) /
            Math.max(totalSupply.amount0.gamma, _pack.minTotalSupply.gamma);
        }

        return _rewardPerTokenStored;&&

    function earned(
        uint256 _id,
        uint256 tokenId_
    ) public view returns (Amount memory) {
        require(_id < packs.length, "Formation.Fi: no pack");
        uint256 amount_ = balances[tokenId_].amount0.alpha +
            balances[tokenId_].amount0.beta +
            balances[tokenId_].amount0.gamma;
        return
            (Math.max(
                packs[_id].minBoostingFactor,
                boostingRewardFactor(tokenId_)
            ) *
                (amount_ *
                    (rewardPerToken(_id) -
                        rewardPerTokenPaid[_id][tokenId_]))) /
            (COEFF_SCALE_DECIMALS * COEFF_SCALE_DECIMALS);
    }

    function stake(
        uint256 tokenId_,
        uint256 amount_,
        Amount memory _weights,
        address to_
    ) public whenNotPaused updateReward {
        require(to_ != address(0), "Formation.Fi: zero address");
        _updateReward(tokenId_);
        weights[tokenId_] = _weights;
        if (amount_ != 0) {
            balances[tokenId_].amount1 += amount_;
            totalSupply.amount1 += amount_;
            token1.safeTransferFrom(msg.sender, address(this), amount_);
        }
        if (tokenId_ != 0) {
            Amount memory _amount0 =  parityStorage.tokenBalancePerToken(tokenId_);
            balances[tokenId_].amount0 = _amount0;
            totalSupply.amount0.alpha += _amount.alpha;
            totalSupply.amount0.beta += _amount.beta;
            totalSupply.amount0.gamma += _amount.gamma;

            holders[tokenId_] = to_;
            parityToken.safeTransferFrom(msg.sender, address(this), tokenId_);
        }

        emit Staked(tokenId_, amount_, to_);
    }

    function unstake(
        uint256 tokenId_,
        uint256 amount_,
        address to_
    ) public whenNotPaused updateReward {
        require(amount_ != 0 || tokenId_ != 0, "Formation.Fi: amount is zero");
        _updateReward(tokenId_);

        if (amount_ != 0) {
            require(
                balances[tokenId_].amount1 >= amount_,
                "Formation.Fi: amount is zero"
            );


            unchecked {
                totalSupply.amount1 -= amount_;
            }
            unchecked {
                balances[tokenId_].amount1 -= amount_;
            }
            token1.safeTransfer(to_, amount_);
        }

        if (tokenId_ != 0) {
            require(holders[tokenId_] == msg.sender, "Formation.Fi: no owner");
            parityToken.safeTransferFrom(address(this), to_, tokenId_);
            totalSupply.amount0.alpha -= balances[tokenId_].amount0.alpha;
            totalSupply.amount0.beta -= balances[tokenId_].amount0.beta;
            totalSupply.amount0.gamma -= balances[tokenId_].amount0.gamma;
            balances[tokenId_].amount0 = Amount(0, 0, 0);
            holders[tokenId_] = address(0);
            emit Unstaked(tokenId_, amount_, to_);
        }
    }

    function claim(uint256 tokenId_, address _to) public updateReward {
        uint256 _reward;
        _updateReward(tokenId_);
        require(holders[tokenId_] == msg.sender, "Formation.Fi: no owner");
        for (uint256 i = 0; i < packs.length; i++) {
            _reward = rewards[i][tokenId_];
            if (_reward > 0) {
                rewards[i][tokenId_] = 0;
                IERC20(packs[i].rewardToken).safeTransferFrom(
                    treasury,
                    _to,
                    _reward
                );
                emit RewardPaid(packs[i].rewardToken, _reward, _to);
            }
        }
    }

    function exit(uint256 tokenId_, address _to) external {
        unstake(tokenId_, balances[tokenId_].amount1, _to);
        claim(tokenId_, _to);
    }

    function supplyTokenReward(
        uint256 _id,
        uint256 _amountToken
    ) external onlyOwner {
        packs[_id].rewardTotal += _amountToken;
        IERC20(packs[_id].rewardToken).transferFrom(
            msg.sender,
            treasury,
            _amountToken
        );
    }

    function boostingRewardFactor(
        uint256 _id,
        uint256 tokenId_
    ) public view returns (Amount memory _factor) {
        require(_id < packs.length, "Formation.Fi: no pack");
        Pack memory _pack = packs[_id];
        Amount memory _amount0 = balances[tokenId_].amount0;
        Amount memory _amount1 = balances[tokenId_].amount1

        _factor.alpha = calculatFactor(_amount0.alpha, _amount1.alpha, _pack.idealAmount.alpha, _pack.idealRatio.alpha);
        _factor.beta = calculatFactor(_amount0.beta, _amount1.beta, _pack.idealAmount.beta, _pack.idealRatio.beta);
        _factor.gamma = calculatFactor(_amount0.gamma, _amount1.gamma, _pack.idealAmount.gamma, _pack.idealRatio.gamma);
        return factor;
    }
    function calculateRatio(uint256 _amount0, uint256 _amount1, uint256 _idealAmount, uint256 _idealRatio) public view returns (uint256 _factor){
            Amount memory _ratio;
            _ratio.amount0 = (_amount0 * COEFF_SCALE_DECIMALS) / _amount1;
            _ratio.amount1 = (_amount1 * COEFF_SCALE_DECIMALS) / idealAmount;
            uint256 _maxRatio = Math.max(_ratio.amount0, _ratio.amount1);
        if (_maxRatio <= _ratio) {
            _factor = _maxRatio;
        } else {
            _factor = COEFF_SCALE_DECIMALS;
        }
    }

    function notifyRewardAmount(
        uint256 _id,
        uint256 _reward,
        uint256 _rewardsDuration
    ) external updateReward {
        _rewardsDuration = Math.max(
            _rewardsDuration,
            packs[_id].rewardDuration
        );
        require(_rewardsDuration > 0, "Formation.Fi: zero rewardsDuration");
        packs[_id].rewardTotal += _reward;
        if (block.timestamp >= packs[_id].periodFinish) {
            packs[_id].rewardPerSecond = _reward / _rewardsDuration;
        } else {
            uint256 remaining = packs[_id].periodFinish - block.timestamp;
            uint256 leftover = remaining * packs[_id].rewardPerSecond;
            packs[_id].rewardPerSecond =
                (_reward + leftover) /
                _rewardsDuration;

            address _rewardToken = packs[_id].rewardToken;
            IERC20(_rewardToken).transferFrom(msg.sender, treasury, _reward);
            uint256 _balance = IERC20(_rewardToken).balanceOf(treasury);
            require(
                packs[_id].rewardPerSecond <= _balance / _rewardsDuration,
                "Formation.Fi: Provided reward too high"
            );
            packs[_id].periodFinish = block.timestamp + _rewardsDuration;
            packs[_id].rewardDuration = _rewardsDuration;
            packs[_id].lastUpdateTime = block.timestamp;
            emit RewardAdded(_id, _reward);
        }
    }

    function getWeightedAmount(
        uint256 tokenId_
    ) public view returns (uint256 amount_) {
        Amount memory weights_ = parityStorage.weightsPerToken(tokenId_);
        amount_ =
            (weights_.alpha *
                balances[tokenId_].amount0.alpha +
                weights_.beta *
                balances[tokenId_].amount0.beta +
                weights_.gamma *
                balances[tokenId_].amount0.gamma) /
            COEFF_SCALE_DECIMALS;
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }
}
